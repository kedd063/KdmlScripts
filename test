-- Geli≈ütirilmi≈ü teleport fonksiyonu
local function TeleportToCoordsImproved(coords)
    if not (coords and #coords == 3) then return false end
    if not hrp then return false end
    
    local target = CFrame.new(coords[1], coords[2], coords[3])
    local maxAttempts = 5
    local successThreshold = 3 -- 3 birimden az fark kabul edilir
    
    for attempt = 1, maxAttempts do
        -- Birden fazla y√∂ntemle teleport dene
        
        -- Y√∂ntem 1: CFrame ile direkt
        hrp.CFrame = target
        task.wait(0.1)
        
        -- Y√∂ntem 2: Position ile
        hrp.Position = target.Position
        task.wait(0.1)
        
        -- Y√∂ntem 3: Velocity sƒ±fƒ±rlama ile
        if hrp:FindFirstChild("AssemblyLinearVelocity") then
            hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end
        hrp.CFrame = target
        task.wait(0.2)
        
        -- Ba≈üarƒ± kontrol√º
        local distance = (hrp.Position - target.Position).Magnitude
        if distance <= successThreshold then
            print("Teleport ba≈üarƒ±lƒ±! Deneme:", attempt, "Mesafe:", math.floor(distance * 100) / 100)
            return true
        end
        
        print("Deneme", attempt, "ba≈üarƒ±sƒ±z. Mesafe:", math.floor(distance * 100) / 100)
        
        -- Sonraki deneme i√ßin biraz bekle
        task.wait(0.3)
    end
    
    print("Teleport ba≈üarƒ±sƒ±z! T√ºm denemeler t√ºkendi.")
    return false
end

-- Network lag kompensasyonu ile teleport
local function TeleportWithNetworkCompensation(coords)
    if not (coords and #coords == 3) then return false end
    if not hrp then return false end
    
    local target = CFrame.new(coords[1], coords[2], coords[3])
    local ping = getPing()
    local compensation = math.max(ping * 2, 0.5) -- Minimum 0.5 saniye bekle
    
    -- Karakteri dondur
    local originalAnchored = hrp.Anchored
    hrp.Anchored = true
    
    -- Teleport
    hrp.CFrame = target
    
    -- Network lag i√ßin bekle
    task.wait(compensation)
    
    -- Karakteri serbest bƒ±rak
    hrp.Anchored = originalAnchored
    
    -- Doƒürulama
    task.wait(0.2)
    local distance = (hrp.Position - target.Position).Magnitude
    
    if distance <= 5 then
        return true
    else
        -- Ba≈üarƒ±sƒ±zsa tekrar dene
        hrp.CFrame = target
        task.wait(0.5)
        return (hrp.Position - target.Position).Magnitude <= 5
    end
end

-- Multi-method teleport (en g√ºvenilir)
local function TeleportMultiMethod(coords)
    if not (coords and #coords == 3) then return false end
    if not hrp then return false end
    
    local target = CFrame.new(coords[1], coords[2], coords[3])
    local methods = {}
    
    -- Y√∂ntem listesi
    methods[1] = function()
        -- Velocity temizle + CFrame
        if hrp:FindFirstChild("AssemblyLinearVelocity") then
            hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end
        if hrp:FindFirstChild("AssemblyAngularVelocity") then
            hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
        end
        hrp.CFrame = target
    end
    
    methods[2] = function()
        -- Anchor + CFrame + Unanchor
        local wasAnchored = hrp.Anchored
        hrp.Anchored = true
        hrp.CFrame = target
        task.wait(0.1)
        hrp.Anchored = wasAnchored
    end
    
    methods[3] = function()
        -- Position + CFrame kombinasyonu
        hrp.Position = target.Position
        task.wait(0.05)
        hrp.CFrame = target
    end
    
    methods[4] = function()
        -- BodyPosition ile
        local bp = Instance.new("BodyPosition")
        bp.MaxForce = Vector3.new(4000, 4000, 4000)
        bp.Position = target.Position
        bp.Parent = hrp
        task.wait(0.3)
        bp:Destroy()
        hrp.CFrame = target
    end
    
    -- Her y√∂ntemi dene
    for i, method in ipairs(methods) do
        method()
        task.wait(0.3)
        
        local distance = (hrp.Position - target.Position).Magnitude
        if distance <= 3 then
            print("Teleport ba≈üarƒ±lƒ±! Y√∂ntem:", i, "Mesafe:", math.floor(distance * 100) / 100)
            return true
        end
    end
    
    -- Son √ßare: Karakter respawn
    print("T√ºm y√∂ntemler ba≈üarƒ±sƒ±z. Karakter yeniden y√ºkleniyor...")
    lp:LoadCharacter()
    
    -- Yeni karakter y√ºklenene kadar bekle
    lp.CharacterAdded:Wait()
    task.wait(1)
    
    -- Yeni karakterle tekrar dene
    if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
        lp.Character.HumanoidRootPart.CFrame = target
        return true
    end
    
    return false
end

-- ADVANCED: Daha da geli≈ümi≈ü s√ºrekli deneme sistemi
local function TeleportUntilSuccessAdvanced(coords)
    if not (coords and #coords == 3) then return false end
    if not hrp then return false end
    
    local target = CFrame.new(coords[1], coords[2], coords[3])
    local attempt = 1
    local maxTime = 45 -- 45 saniye s√ºrekli dene
    local startTime = tick()
    local consecutiveFails = 0
    
    print("üöÄ ADVANCED S√úREKLI TELEPORT BA≈ûLADI")
    print("üìç Hedef Koordinatlar:", coords[1], coords[2], coords[3])
    
    -- Teleport sƒ±rasƒ±nda karakteri stabilize et
    local originalWalkSpeed = humanoid.WalkSpeed
    humanoid.WalkSpeed = 0
    
    while tick() - startTime < maxTime do
        local currentTime = tick() - startTime
        print("üîÑ Deneme", attempt, "- Ge√ßen S√ºre:", math.floor(currentTime * 10) / 10, "sn")
        
        -- Dinamik y√∂ntem se√ßimi - ba≈üarƒ±sƒ±zlƒ±k sayƒ±sƒ±na g√∂re
        local methodIndex = ((attempt - 1) % 5) + 1
        
        -- √áok ba≈üarƒ±sƒ±zlƒ±k varsa daha agresif y√∂ntemler kullan
        if consecutiveFails > 3 then
            methodIndex = 5 -- Karakter respawn y√∂ntemi
        end
        
        if methodIndex == 1 then
            -- Y√∂ntem 1: Basit CFrame
            hrp.CFrame = target
            
        elseif methodIndex == 2 then
            -- Y√∂ntem 2: Double CFrame (iki kez)
            hrp.CFrame = target
            task.wait(0.05)
            hrp.CFrame = target
            
        elseif methodIndex == 3 then
            -- Y√∂ntem 3: Velocity sƒ±fƒ±rlama + Anchor
            if hrp:FindFirstChild("AssemblyLinearVelocity") then
                hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            end
            local wasAnchored = hrp.Anchored
            hrp.Anchored = true
            hrp.CFrame = target
            task.wait(0.15)
            hrp.Anchored = wasAnchored
            
        elseif methodIndex == 4 then
            -- Y√∂ntem 4: BodyPosition ile zorla
            local bp = Instance.new("BodyPosition")
            bp.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bp.P = 3000
            bp.D = 500
            bp.Position = target.Position
            bp.Parent = hrp
            
            task.wait(0.5)
            bp:Destroy()
            hrp.CFrame = target
            
        elseif methodIndex == 5 then
            -- Y√∂ntem 5: Son √ßare - Karakter respawn
            print("üîÑ Son √ßare y√∂ntemi - Karakter yeniden y√ºkleniyor...")
            local respawnPos = target
            
            lp:LoadCharacter()
            
            -- Yeni karakter gelene kadar bekle
            local newChar = lp.CharacterAdded:Wait()
            task.wait(2) -- Tam y√ºklenmesi i√ßin bekle
            
            local newHrp = newChar:WaitForChild("HumanoidRootPart", 5)
            if newHrp then
                newHrp.CFrame = respawnPos
                print("‚úÖ Karakter respawn ile teleport tamamlandƒ±!")
                return true
            end
        end
        
        -- Kontrol i√ßin bekle
        task.wait(0.25)
        
        -- Ba≈üarƒ± kontrol√º
        local distance = (hrp.Position - target.Position).Magnitude
        if distance <= 4 then
            consecutiveFails = 0
            print("‚úÖ TELEPORT BA≈ûARILI!")
            print("üìä ƒ∞statistikler:")
            print("   ‚Ä¢ Deneme Sayƒ±sƒ±:", attempt)
            print("   ‚Ä¢ Toplam S√ºre:", math.floor((tick() - startTime) * 100) / 100, "saniye")
            print("   ‚Ä¢ Son Mesafe:", math.floor(distance * 100) / 100, "birim")
            print("   ‚Ä¢ Kullanƒ±lan Y√∂ntem:", methodIndex)
            
            -- Walkspeed'i geri y√ºkle
            humanoid.WalkSpeed = originalWalkSpeed
            return true
        else
            consecutiveFails = consecutiveFails + 1
            print("‚ùå Ba≈üarƒ±sƒ±z - Mesafe:", math.floor(distance * 100) / 100, "Ardƒ±≈üƒ±k Ba≈üarƒ±sƒ±zlƒ±k:", consecutiveFails)
        end
        
        attempt = attempt + 1
        
        -- Adaptif bekleme s√ºresi
        local waitTime = 0.1 + (consecutiveFails * 0.1) -- Ba≈üarƒ±sƒ±zlƒ±k arttƒ±k√ßa daha fazla bekle
        if attempt % 15 == 0 then
            print("‚è∞ 15 deneme tamamlandƒ±, uzun bekleme...")
            waitTime = 2
        end
        
        task.wait(waitTime)
    end
    
    print("‚è∞ ZAMAN A≈ûIMI! 45 saniyede teleport ba≈üarƒ±sƒ±z oldu.")
    humanoid.WalkSpeed = originalWalkSpeed -- Walkspeed'i geri y√ºkle
    return false
end

-- Ana teleport fonksiyonu - artƒ±k s√ºrekli deneme sistemi kullanƒ±yor
local function TeleportToCoordsSimple(coords)
    -- Advanced s√ºrekli deneme sistemini kullan
    return TeleportUntilSuccessAdvanced(coords)
end

-- Teleport effect fonksiyonu - real-time updates ile
local function TeleportWithEffect(coords)
    print("üéØ TELEPORT EFFECT BA≈ûLADI:", coords[1], coords[2], coords[3])
    
    overlay.Visible = true
    overlayText.Text = "KDML SCRIPTS - TELEPORTING..."
    task.spawn(startRGB)
    
    -- Ba≈üka bir thread'de teleport yap, b√∂ylece overlay devam eder
    local success = false
    local teleportThread = task.spawn(function()
        success = TeleportToCoordsSimple(coords)
    end)
    
    -- Teleport devam ederken overlay'i g√ºncelle
    local startTime = tick()
    while not success and (tick() - startTime) < 45 do
        local elapsed = math.floor(tick() - startTime)
        overlayText.Text = "KDML SCRIPTS - TELEPORTING... (" .. elapsed .. "s)"
        task.wait(1)
        
        -- Thread bitip bitmediƒüini kontrol et
        if coroutine.status(teleportThread) == "dead" then
            break
        end
    end
    
    -- Sonu√ß g√∂ster
    if success then
        overlayText.Text = "KDML SCRIPTS - TELEPORT SUCCESSFUL! ‚úÖ"
        overlayText.TextColor3 = Color3.new(0, 1, 0)
        task.wait(2)
    else
        overlayText.Text = "KDML SCRIPTS - TELEPORT FAILED! ‚ùå"
        overlayText.TextColor3 = Color3.new(1, 0, 0)
        task.wait(3)
    end
    
    stopRGB()
    overlay.Visible = false
    overlayText.Text = "KDML SCRIPTS TELEPORTING YOU"
    overlayText.TextColor3 = Color3.new(1, 0, 0) -- Orijinal renge geri d√∂n
    
    return success
end
